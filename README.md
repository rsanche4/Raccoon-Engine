# RACCOON ENGINE

This project is a full-featured retro-style 3D engine inspired by DOOM, including an intuitive sector-based editor that lets you build worlds with customizable wall heights, floors, ceilings, and more - just like the classics. It uses a Binary Space Partitioning (BSP) tree to efficiently sort polygons for correct rendering order. The engine supports directional sprites and textured walls, allowing you to create complex elements like fences and detailed environments. Built entirely in Python with native scripting, it seamlessly integrates any Python library for AI, procedural generation, or advanced gameplay logic. To maintain performance on a classic 320x240 resolution canvas (a nod to DOOM's original), it implements a front-to-back rendering approach combined with an efficient NumPy-based pixel masking technique that avoids unnecessary overdrawing. Additionally, radius-based culling limits rendering distance, ensuring smooth performance even on complex maps. The engine leverages Pygame for rendering and uses minimal dependencies for speed and simplicity, making it an accessible and extensible platform for retro 3D game development and experimentation.

The rendering pipeline begins with a user-defined 3D spatial layout composed of vertex-quadrilateral-texture tuples authored via an editor and is immediately subjected to Binary Space Partitioning tree construction to enable deterministic, non-overlapping front-to-back traversal using reversed Painter's Algorithm, after which the runtime engine injects the player camera into the world space and begins depth-aware raster sequencing by projecting geometry into normalized screen space under a capped quad budget, with each polygon undergoing perspective textured mapping while simultaneously performing per-fragment visibility rejection based on previously rendered pixel states to eliminate overdraw, followed by hierarchical floor rendering from the highest elevation downward using occlusion-culling logic, after which sprite entities are sorted by distance and each is subjected to a 2D grid-space ray traversal using Digital Differential Analyzer algorithm to verify potential visibility and line-of-sight interaction with the player, culminating in selective projection and rendering based on directional alignment and angle of incidence, before the engine scans the framebuffer for unresolved pixel domains to procedurally inject a parallax-mapped skybox background, and finally, all UI overlays and post-processing elements are composited atop the entire visual stack with full-layer alpha blending to complete the frame.

Here the last paragraph will be inclduing all the different features like lighting and all those things.




Note; For reading map data, the vertices are actually like this:
x value, z value, floor height will be your y value. For when you dont have a ceilign. So you need to know how to read each type but basically thats that.
Also keep in mind player starts at a specifc place. We need to shift all these vertices basically by that amount so it looks accurate.
The other thing is make sure this works! test the edtior and ensure that it doesnt have any weird bugs and it loads maps, and it is capable of drawing all the worlds!